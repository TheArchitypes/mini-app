'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Table = exports.SORT_DECENDING = exports.SORT_ASCENDING = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _pagination = require('./pagination');

var _icons = require('../atoms/icons');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SORT_ASCENDING = exports.SORT_ASCENDING = 'asc';
var SORT_DECENDING = exports.SORT_DECENDING = 'desc';

/**
 * Used as renderRow function if not provided by props
 */
function defaultRenderRow(rowData, columns) {
  var rowColumns = Object.keys(rowData).map(function (key, index) {
    // if columns were provided...
    if (columns.length > 0) {
      // check the columns object to figure out which property(path) we're looking for
      var path = _lodash2.default.get(columns, [index, 'path']);
      return _react2.default.createElement(
        'td',
        { key: key },
        _lodash2.default.get(rowData, path)
      );
    }
    // else just return the next property on the rowData object (use key)
    return _react2.default.createElement(
      'td',
      { key: key },
      _lodash2.default.toString(_lodash2.default.get(rowData, key))
    );
  });

  return _react2.default.createElement(
    'tr',
    null,
    rowColumns
  );
}

/**
 * Used as the click handler for column header if not provided via props
 * @param {*} column
 */
function defaultOnHeaderClick(column) {
  // toggle the sort direction
  var sortDirection = this.state.sortDirection === SORT_DECENDING || null ? SORT_ASCENDING : SORT_DECENDING;
  this.setState({
    sortBy: column.path,
    sortDirection: sortDirection
  });
}

/**
 * Table Component
 */

var Table = exports.Table = function (_Component) {
  _inherits(Table, _Component);

  function Table(props) {
    _classCallCheck(this, Table);

    var _this = _possibleConstructorReturn(this, (Table.__proto__ || Object.getPrototypeOf(Table)).call(this, props));

    var initialSortBy = props.initialSortBy,
        initialSortDirection = props.initialSortDirection,
        initialPage = props.initialPage;

    _this.state = {
      sortBy: initialSortBy,
      sortDirection: initialSortDirection,
      currentPage: initialPage
    };
    _this.defaultOnHeaderClick = defaultOnHeaderClick.bind(_this);
    return _this;
  }

  _createClass(Table, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          columns = _props.columns,
          data = _props.data,
          renderRow = _props.renderRow,
          sort = _props.sort,
          recordsPerPage = _props.recordsPerPage,
          padTableRows = _props.padTableRows;
      var _state = this.state,
          sortBy = _state.sortBy,
          sortDirection = _state.sortDirection,
          currentPage = _state.currentPage;

      var onHeaderClick = this.props.onHeaderClick || this.defaultOnHeaderClick;

      // default pagination values
      var totalPages = 1;
      var startAtIndex = 0;
      var endAtIndex = data.length - 1;

      // if recordsPerPage is set...
      if (recordsPerPage != null) {
        // calculate totalPages by dividing and rounding up...
        totalPages = _lodash2.default.ceil(_lodash2.default.divide(data.length, recordsPerPage));
        // calcuate start at....
        // if page 0: start at 0, and end at (recordsPerPage - 1)
        if (currentPage === 0) {
          startAtIndex = 0;
          endAtIndex = recordsPerPage - 1;
        } else {
          // else we are not at page 0...
          startAtIndex = currentPage * recordsPerPage;
          endAtIndex = currentPage * recordsPerPage + (recordsPerPage - 1);
        }
      }

      // sort the data
      var sortedData = sort(data, sortBy, sortDirection);
      // get the rows that we need for this page
      var tableRows = sortedData.slice(startAtIndex, endAtIndex + 1).map(function (dataRow) {
        return renderRow(dataRow, columns);
      });

      if (padTableRows) {
        var colsToSpan = void 0;
        // if we have columns, span as many as there are...
        if (columns.length > 0) {
          colsToSpan = columns.length;
        } else {
          colsToSpan = Object.keys(data[0]).length();
        }

        while (tableRows.length < recordsPerPage) {
          tableRows = tableRows.concat(_react2.default.createElement(
            'tr',
            null,
            _react2.default.createElement(
              'td',
              { colSpan: colsToSpan },
              '\xA0'
            )
          ));
        }
      }

      return _react2.default.createElement(
        'div',
        { className: 'kubra-table-container' },
        _react2.default.createElement(
          'table',
          { className: 'kubra-table striped' },

          // if columns are defined, render the headers
          columns.length > 0 && _react2.default.createElement(
            'thead',
            null,
            _react2.default.createElement(
              'tr',
              null,

              // iterate through the columns to render table headers
              columns.map(function (column, index) {
                return _react2.default.createElement(
                  'th',
                  {
                    key: index,
                    className: '' + (column.canSort ? 'sortable' : null),
                    onClick: function onClick() {
                      // if sort is enabled, handle click
                      if (column.canSort) {
                        onHeaderClick(column);
                      }
                    }
                  },
                  _react2.default.createElement(
                    'div',
                    { className: 'kubra-table-header' },
                    _react2.default.createElement(
                      'div',
                      { className: 'name' },
                      column.name
                    ),
                    _react2.default.createElement(
                      'div',
                      { className: 'icon' },

                      // if we are currenly sorting by this column, add icon
                      sortBy === column.path ? _react2.default.createElement(_icons.Icon, {
                        className: 'small',
                        name: sortDirection === SORT_ASCENDING ? 'caret-top' : 'caret-bottom'
                      }) : null
                    )
                  )
                );
              })
            )
          ),
          _react2.default.createElement(
            'tbody',
            null,
            tableRows
          )
        ),

        // if recordsPerPage is not null...
        recordsPerPage != null ?
        // ...then show pagination
        _react2.default.createElement(
          'div',
          { className: 'kubra-table-pagination' },
          _react2.default.createElement(_pagination.Pagination, {
            onClick: function onClick(index) {
              _this2.setState({ currentPage: index });
            },
            currentPage: this.state.currentPage,
            totalPages: totalPages
          })
        ) :
        // ...else don't show pagination
        null
      );
    }
  }]);

  return Table;
}(_react.Component);

{
  var arrayOf = _propTypes2.default.arrayOf,
      shape = _propTypes2.default.shape,
      func = _propTypes2.default.func,
      number = _propTypes2.default.number,
      string = _propTypes2.default.string,
      bool = _propTypes2.default.bool;

  Table.propTypes = {
    /**
     * An object representing the table columns
     * @prop {string} name the value to be rendered in the th element
     * @prop {string} path the path to use on the data object (row) when sorting or displaying
     * @prop {bool}   canSort a boolean to determine if a column is sortable or not
     */
    columns: arrayOf(shape({})),
    /**
     * An array of objects representing the table data
     * Each element of the array representing a row
     */
    data: arrayOf(shape({})),
    /**
     * A function to handle rendering a row
     * @param {*} rowData the object representing the row (from the data array)
     * @param {*} columns the columns object
     * @return {*} JSX element
     */
    renderRow: func,
    /**
     * A function to handle sorting the data
     * @param {*} data the data to be sorted (table data)
     * @param {*} sortBy the property on each data element that will be compared
     * @param {*} sortDirection the sort direction (ASC/DESC)
     * @return sorted data
     */
    sort: func,
    /**
     * A function to handle header click
     * @param {*} column the column object associated with the header that was clicked
     */
    onHeaderClick: func,
    /** Number of records to show on each page, default is null which disables pagination */
    recordsPerPage: number,
    /** Inital column to sort, equal to path on column, default is no sorting */
    initialSortBy: string,
    /** Initial sort direction, default is SORT_ASCENDING */
    initialSortDirection: string,
    /** Initial page number */
    initialPage: number,
    /** Flag to pad table rows (keep consistent table height) */
    padTableRows: bool
  };

  Table.defaultProps = {
    columns: [],
    data: [],
    renderRow: defaultRenderRow,
    sort: _lodash2.default.orderBy,
    onHeaderClick: null,
    recordsPerPage: null,
    initialSortBy: null,
    initialSortDirection: null,
    initialPage: 0,
    padTableRows: false
  };
}

exports.default = {
  Table: Table
};