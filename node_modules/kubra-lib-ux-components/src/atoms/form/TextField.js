import React, { Component } from 'react';
import autobind from 'class-autobind';
import PropTypes from 'prop-types';
import _ from 'lodash';
import { mergeClassNames } from '../../lib/mergeClassNames';
import htmlProps from '../../lib/htmlProps';
import twoWay from '../../lib/twoWay';
import getIdWithSuffix from '../../lib/getIdWithSuffix';
import getStringDifference from '../../lib/getStringDifference';
import getCaretPos from '../../lib/getCaretPos';

export class TextField extends Component {
  constructor(props) {
    super(props);
    this.state = {
      hasFocus: false,
      lastValue: props.value || '',
      indexForAutocomplete: '',
      autocompleteValue: '',
      autocompleteItemsToShow: [],
      showAutocomplete: false,
      onHover: null,
    };
    autobind(this);
  }

  onFocus() {
    this.setState({
      hasFocus: true,
    });
  }

  onBlur() {
    if (this.state.onHover === null) {
      this.setState({
        hasFocus: false,
        showAutocomplete: false,
        onHover: null,
      });
    }
  }

  onClickAutocompleteItem(item) {
    return () => {
      const { indexForAutocomplete, lastValue } = this.state;

      const nextValue = lastValue.slice(0, indexForAutocomplete - 1)
        + item.label
        + lastValue.slice(indexForAutocomplete - 1);
      this.props.onChange(nextValue);
      this.hideAutocomplete(nextValue);
    };
  }

  onMouseOverAutocompleteItem(index) {
    return () => {
      this.setState({
        onHover: index,
      });
    };
  }

  onMouseOutAutocompleteItem(index) {
    return () => {
      if (this.state.onHover === index) {
        this.setState({
          onHover: null,
        });
      }
    };
  }

  onKeyUp(e) {
    const { onHover, autocompleteItemsToShow, showAutocomplete } = this.state;

    if (showAutocomplete) {
      switch (e.keyCode) {
        case 38: // up arrow
          this.setCurrentOnHover((onHover !== null ? onHover - 1 : 0), autocompleteItemsToShow);
          break;
        case 40: // down arrow
          this.setCurrentOnHover((onHover !== null ? onHover + 1 : 0), autocompleteItemsToShow);
          break;
        case 9: // tab
        case 13: // enter
          e.preventDefault();
          if (autocompleteItemsToShow[onHover]) {
            this.onClickAutocompleteItem(autocompleteItemsToShow[onHover])();
          }
          break;
        case 27: // esc
          this.hideAutocomplete();
          break;
        default:
          break;
      }
    }
  }

  onKeyDown(e) {
    const { showAutocomplete } = this.state;

    if (showAutocomplete) {
      switch (e.keyCode) {
        case 38: // up arrow
        case 40: // down arrow
        case 9: // tab
        case 13: // enter
          // Prevent default behaviour. Needs to be done in onKeyDown.
          e.preventDefault();
          break;
        default:
          break;
      }
    }
  }

  setCurrentOnHover(index, numberOfItems) {
    if (numberOfItems.length > 0) {
      if (index === null) {
        this.setState({
          onHover: 0,
        });
      } else if (index <= -1) {
        this.setState({
          onHover: numberOfItems.length - 1,
        });
      } else {
        this.setState({
          onHover: index % numberOfItems.length,
        });
      }
    }
  }

  handleChange(e) {
    if (this.props.onChange) {
      this.props.onChange(e.target.value);
    }
    if (this.props.autocompleteItems.length > 0) {
      this.handleAutocomplete(e.target.value, getCaretPos(e.target));
    }
  }

  handleAutocomplete(value, caretPos) {
    const { autocompleteItems } = this.props;
    const { showAutocomplete, lastValue } = this.state;
    let autocompleteItemsToShow = [];
    const autocompleteIdentifierCount = ((value || '').match(/\$/g) || []).length - ((lastValue || '').match(/\$/g) || []).length;

    if (!showAutocomplete && autocompleteIdentifierCount > 0) {
      // if autocompleteItems has an item that starts with the last letter, show autocomplete
      autocompleteItemsToShow = autocompleteItems;
      if (autocompleteItemsToShow.length > 0) {
        this.setState({
          showAutocomplete: true,
          autocompleteItemsToShow,
          autocompleteValue: '$',
          indexForAutocomplete: caretPos,
        });
      } else {
        this.setState({
          lastValue: value,
        });
      }
    } else if (showAutocomplete) {
      if (autocompleteIdentifierCount > 1) {
        this.hideAutocomplete(value);
        return;
      }
      // if a letter was added, Add last letter typed to autocompleteValue
      const nextAutocompleteValue = getStringDifference(value, lastValue);

      if (_.isEmpty(nextAutocompleteValue)) {
        this.hideAutocomplete(value);
        return;
      }
      autocompleteItemsToShow = autocompleteItems.filter(
        item => item.label.toLowerCase().indexOf(nextAutocompleteValue.toLowerCase()) > -1,
      );

      if (autocompleteItemsToShow.length > 0) {
        this.setState({
          autocompleteItemsToShow,
          autocompleteValue: nextAutocompleteValue,
        });
      } else {
        this.hideAutocomplete(value);
      }
    } else {
      this.setState({
        lastValue: value,
      });
    }
  }

  hideAutocomplete(value) {
    this.setState({
      showAutocomplete: false,
      lastValue: value,
      onHover: null,
    });
  }

  autocompleteProps() {
    const { autocompleteItems } = this.props;
    if (autocompleteItems.length > 0) {
      return {
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        onKeyUp: this.onKeyUp,
        onKeyDown: this.onKeyDown,
        autoComplete: 'off', // Ignore browser's default autocomplete functionality
      };
    }
    return {};
  }

  render() {
    const {
      name,
      type,
      label,
      hintText,
      defaultValue,
      disabled,
      className,
      onChange,
      value,
      hexCode,
      iconic,
      autocompleteItems,
      maxLength,
      disableMaxLengthLabel,
    } = this.props;
    const {
      showAutocomplete,
      autocompleteItemsToShow,
      onHover,
    } = this.state;

    const inputId = getIdWithSuffix(this.props, 'input');
    const inputClassName = mergeClassNames(
      `${hexCode || iconic ? 'input-hex-code' : ''}`,
      'text-field',
    );
    const hasAutocomplete = autocompleteItems.length > 0;
    const _label = (maxLength && !disableMaxLengthLabel) ? `${label} - Max ${maxLength} Characters` : label;

    return (
      <div {...htmlProps(this.props)} className={mergeClassNames(`text-field ${hasAutocomplete ? 'autocomplete' : ''}`, className)}>
        {label && <label htmlFor={name}>{_label}</label>}
        <input
          {...twoWay({ onChange, value })}
          {...this.autocompleteProps()}
          onChange={this.handleChange}
          type={type}
          className={inputClassName}
          name={name}
          disabled={disabled}
          defaultValue={defaultValue}
          placeholder={hintText}
          id={inputId}
          maxLength={maxLength}
        />
        {hexCode &&
          <div className="input-hex-code-swatch" style={{ backgroundColor: `${value}` }} />
        }
        {iconic &&
          <span className="input-iconic-swatch icon iconic small" data-glyph={value} />
        }
        { showAutocomplete &&
          <div className="autocomplete-menu">
            {autocompleteItemsToShow.map((item, index) =>
              (<a
                key={item.id}
                className={`autocomplete-item ${onHover === index ? 'hover' : ''}`}
                href={`#${index}`}
                onClick={this.onClickAutocompleteItem(item)}
                onMouseOver={this.onMouseOverAutocompleteItem(index)}
                onMouseOut={this.onMouseOutAutocompleteItem(index)}
              >
                {item.label}
              </a>),
            )}
          </div>
        }
      </div>
    );
  }
}

{
  const { string, oneOfType, bool, number, func, arrayOf, shape } = PropTypes;
  TextField.propTypes = {
    defaultValue: oneOfType([string, number]),
    type: string,
    name: string.isRequired,
    hintText: string.isRequired,
    disabled: bool,
    label: string,
    className: string,
    value: string,
    onChange: func,
    hexCode: bool,
    iconic: bool,
    autocompleteItems: arrayOf(shape({})),
    maxLength: number,
    disableMaxLengthLabel: bool,
  };

  TextField.defaultProps = {
    defaultValue: undefined,
    disabled: false,
    type: 'text',
    label: null,
    className: '',
    value: undefined,
    onChange: undefined,
    hexCode: false,
    iconic: false,
    autocompleteItems: [],
    maxLength: undefined,
    disableMaxLengthLabel: false,
  };
}

export default {
  TextField,
};
